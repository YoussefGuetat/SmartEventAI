pipeline {
    agent any

    tools {
        maven 'M2_HOME'
        jdk 'JAVA_HOME'
    }

    environment {
        // Global
        GITHUB_REPO_URL = 'https://github.com/YoussefGuetat/SmartEventAI.git'
        GIT_BRANCH = 'main'
        GITHUB_CREDENTIALS = 'github_credentials'
        DOCKER_HUB_CREDENTIALS = 'dockerhubcr'
        DOCKERHUB_NAMESPACE = 'guetatyoussef'

        // Downstream
        DOWNSTREAM_PIPELINE = 'SmartEvent_CD'

        // SonarQube
        SONAR_HOST_URL = 'http://localhost:9000'
        SONAR_LOGIN = credentials('sonar11')

        // Services
        //SPRING_SERVICES = 'config-server,eureka-server,gateway-service,auth-service,event-service'
        SPRING_SERVICES = 'config-server'
        NODE_SERVICES = 'workflow-service'
        PYTHON_SERVICES = 'ai-service'
        ANGULAR_SERVICES = 'frontAdmin'
        
        // PostgreSQL Configuration
        POSTGRES_CONTAINER = 'smartevent-postgres-ci'
        POSTGRES_DB = 'auth_db'
        POSTGRES_USER = 'auth_user'
        POSTGRES_PASSWORD = 'auth123'
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "=========================================="
                    echo "  SmartEvent AI - Unified CI Pipeline"
                    echo "  Build #${BUILD_NUMBER}"
                    echo "=========================================="

                    // Initialize global build registry
                    BUILD_REGISTRY = [:]

                    // Clone repository
                    git url: env.GITHUB_REPO_URL,
                        branch: env.GIT_BRANCH,
                        credentialsId: env.GITHUB_CREDENTIALS
                }
            }
        }

 /*  stage('Setup PostgreSQL for Testing') {
    steps {
        script {
            echo "ðŸ˜ Setting up PostgreSQL for testing..."
            
            try {
                // ArrÃªter TOUS les containers PostgreSQL qui utilisent le port 5432
                sh """
                    # Trouver et arrÃªter tous les containers sur le port 5432
                    docker ps -q --filter "publish=5432" | xargs -r docker stop
                    
                    # Supprimer les anciens containers postgres
                    docker ps -aq --filter "name=postgres" | xargs -r docker rm -f
                    
                    # Attendre un peu
                    sleep 2
                """
                
                // DÃ©marrer PostgreSQL
                sh """
                    docker run -d \
                        --name ${POSTGRES_CONTAINER} \
                        -e POSTGRES_USER=${POSTGRES_USER} \
                        -e POSTGRES_PASSWORD=${POSTGRES_PASSWORD} \
                        -e POSTGRES_DB=${POSTGRES_DB} \
                        -p 5432:5432 \
                        postgres:15-alpine
                """
                
                // Attendre que PostgreSQL soit prÃªt
                echo "â³ Waiting for PostgreSQL to be ready..."
                sh """
                    timeout 30 bash -c 'until docker exec ${POSTGRES_CONTAINER} pg_isready -U ${POSTGRES_USER}; do
                        echo "Waiting for PostgreSQL..."
                        sleep 2
                    done'
                """
                
                // VÃ©rifier la connexion
                sh """
                    docker exec ${POSTGRES_CONTAINER} psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT version();"
                """
                
                echo "âœ… PostgreSQL is ready and running"
                
                // Stocker les infos de connexion
                BUILD_REGISTRY['postgres'] = [
                    container: POSTGRES_CONTAINER,
                    host: 'localhost',
                    port: '5432',
                    database: POSTGRES_DB,
                    user: POSTGRES_USER,
                    password: POSTGRES_PASSWORD
                ]
                
            } catch (Exception e) {
                echo "âŒ Failed to setup PostgreSQL: ${e.message}"
                error("PostgreSQL setup failed")
            }
        }
    }
}

        stage('Build Spring Services') {
            steps {
                script {
                    def services = env.SPRING_SERVICES.split(',')

                    for (service in services) {
                        stage("Build ${service}") {
                            dir(service) {
                                echo "ðŸ“¦ Building ${service}..."
                                sh 'mvn clean package -DskipTests'

                                def artifactId = sh(
                                    script: "mvn help:evaluate -Dexpression=project.artifactId -q -DforceStdout",
                                    returnStdout: true
                                ).trim()

                                def version = sh(
                                    script: "mvn help:evaluate -Dexpression=project.version -q -DforceStdout",
                                    returnStdout: true
                                ).trim()

                                def jarFile = "target/${artifactId}-${version}.jar"

                                if (!fileExists(jarFile)) {
                                    error "JAR not found: ${jarFile}"
                                }

                                archiveArtifacts artifacts: jarFile, fingerprint: true

                                BUILD_REGISTRY[service] = [
                                    type: 'spring',
                                    artifactId: artifactId,
                                    version: version,
                                    jarFile: jarFile
                                ]

                                echo "âœ… ${service} built successfully"
                            }
                        }
                    }
                }
            }
        }*/

      /* stage('Test Spring Services with PostgreSQL') {
            steps {
                script {
                    def services = env.SPRING_SERVICES.split(',')

                    for (service in services) {
                        stage("Test ${service}") {
                            dir(service) {
                                echo "ðŸ§ª Testing ${service} with PostgreSQL..."
                                
                                // Configurer les variables d'environnement pour les tests
                                withEnv([
                                    "SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/${POSTGRES_DB}",
                                    "SPRING_DATASOURCE_USERNAME=${POSTGRES_USER}",
                                    "SPRING_DATASOURCE_PASSWORD=${POSTGRES_PASSWORD}"
                                ]) {
                                    sh 'mvn test || true'
                                }
                            }
                        }
                    }
                }
            }
        }

      stage('SonarQube - Spring Services') {
            steps {
                script {
                    def services = env.SPRING_SERVICES.split(',')

                    for (service in services) {
                        stage("SonarQube ${service}") {
                            dir(service) {
                                echo "ðŸ” Analyzing ${service}..."
                                sh """
                                mvn sonar:sonar \
                                    -Dsonar.projectKey=${service} \
                                    -Dsonar.host.url=${SONAR_HOST_URL} \
                                    -Dsonar.login=${SONAR_LOGIN} || true
                                """
                            }
                        }
                    }
                }
            }
        }

        stage('Build Python Services') {
            steps {
                script {
                    def services = env.PYTHON_SERVICES.split(',')

                    for (service in services) {
                        stage("Build ${service}") {
                            dir(service) {
                                echo "ðŸ Building ${service}..."
                                
                                sh '''
                                    python3 -m venv venv
                                    . venv/bin/activate
                                    python -m pip install --upgrade pip
                                    python -m pip install pytest pytest-cov pylint
                                '''

                                sh '''
                                    . venv/bin/activate
                                    python -m pylint main.py || true
                                    python -m pytest --cov=. --cov-report=xml || true
                                '''

                                sh """
                                    sonar-scanner \
                                        -Dsonar.projectKey=${service} \
                                        -Dsonar.sources=. \
                                        -Dsonar.host.url=${SONAR_HOST_URL} \
                                        -Dsonar.login=${SONAR_LOGIN} \
                                        -Dsonar.python.coverage.reportPaths=coverage.xml || true
                                """

                                BUILD_REGISTRY[service] = [
                                    type: 'python',
                                    version: '1.0.0'
                                ]

                                echo "âœ… ${service} built successfully"
                            }
                        }
                    }
                }
            }
        }*/

        /*stage('Build Node.js Services') {
            steps {
                script {
                    def services = env.NODE_SERVICES.split(',')

                    for (service in services) {
                        stage("Build ${service}") {
                            dir(service) {
                                echo "ðŸ“¦ Building ${service}..."
                                sh 'npm install'
                                sh 'npm run lint || true'
                                sh 'npm test || true'

                                sh """
                                sonar-scanner \
                                    -Dsonar.projectKey=${service} \
                                    -Dsonar.sources=. \
                                    -Dsonar.host.url=${SONAR_HOST_URL} \
                                    -Dsonar.login=${SONAR_LOGIN} || true
                                """

                                BUILD_REGISTRY[service] = [
                                    type: 'nodejs',
                                    version: '1.0.0'
                                ]

                                echo "âœ… ${service} built successfully"
                            }
                        }
                    }
                }
            }
        }*/

      stage('Build Angular Frontends') {
            steps {
                script {
                    def services = env.ANGULAR_SERVICES.split(',')

                    for (service in services) {
                        stage("Build ${service}") {
                            dir(service) {
                                echo "ðŸ…°ï¸ Building ${service}..."
                                
                                sh '''
                                    echo "Node version: $(node --version)"
                                    echo "NPM version: $(npm --version)"
                                    npm install
                                    npm run lint 2>/dev/null || echo "âš ï¸ No lint script"
                                    npm run test:ci 2>/dev/null || echo "âš ï¸ No test script"
                                    npm run build -- --configuration production || npm run build --prod
                                '''

                                sh """
                                    if command -v sonar-scanner &> /dev/null; then
                                        sonar-scanner \
                                            -Dsonar.projectKey=${service} \
                                            -Dsonar.sources=src \
                                            -Dsonar.host.url=${SONAR_HOST_URL} \
                                            -Dsonar.login=${SONAR_LOGIN} || true
                                    else
                                        echo "âš ï¸ sonar-scanner not installed, skipping analysis"
                                    fi
                                """

                                BUILD_REGISTRY[service] = [
                                    type: 'angular',
                                    version: '1.0.0'
                                ]

                                echo "âœ… ${service} built successfully"
                            }
                        }
                    }
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                script {
                    echo "ðŸ³ Building Docker images for all services..."

                    def allServices = []
                    allServices.addAll(env.SPRING_SERVICES.split(','))
                    allServices.addAll(env.PYTHON_SERVICES.split(','))
                    allServices.addAll(env.NODE_SERVICES.split(','))
                    allServices.addAll(env.ANGULAR_SERVICES.split(','))

                    def successfulServices = allServices.findAll { service ->
                        BUILD_REGISTRY.containsKey(service) && BUILD_REGISTRY[service] != null
                    }

                    if (successfulServices.isEmpty()) {
                        echo "âš ï¸ No services to build Docker images for"
                        return
                    }

                    echo "ðŸ“¦ Building Docker images for: ${successfulServices.join(', ')}"

                    for (service in successfulServices) {
                        stage("Docker Build ${service}") {
                            dir(service) {
                                def metadata = BUILD_REGISTRY[service]
                                def serviceNameLower = service.toLowerCase()
                                def imageName = "${DOCKERHUB_NAMESPACE}/${serviceNameLower}"
                                def imageTag = "build-${BUILD_NUMBER}"

                                echo "ðŸ³ Building Docker image: ${imageName}:${imageTag}"

                                if (fileExists('Dockerfile')) {
                                    try {
                                        if (metadata.type == 'spring' && metadata.jarFile) {
                                            if (fileExists(metadata.jarFile)) {
                                                docker.build("${imageName}:${imageTag}", "--build-arg JAR_FILE=${metadata.jarFile} .")
                                            } else {
                                                echo "âš ï¸ JAR file not found: ${metadata.jarFile}"
                                                error("JAR file not found")
                                            }
                                        } else {
                                            docker.build("${imageName}:${imageTag}", ".")
                                        }

                                        docker.image("${imageName}:${imageTag}").tag('latest')

                                        BUILD_REGISTRY[service].dockerImage = imageName
                                        BUILD_REGISTRY[service].dockerTag = imageTag

                                        echo "âœ… Docker image built: ${imageName}:${imageTag}"
                                    } catch (Exception e) {
                                        echo "âŒ Failed to build Docker image for ${service}: ${e.message}"
                                    }
                                } else {
                                    echo "âš ï¸ Dockerfile not found for ${service}"
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Push Docker Images') {
            steps {
                script {
                    echo "ðŸ“¤ Pushing Docker images to Docker Hub..."

                    def allServices = []
                    allServices.addAll(env.SPRING_SERVICES.split(','))
                    allServices.addAll(env.PYTHON_SERVICES.split(','))
                    allServices.addAll(env.NODE_SERVICES.split(','))
                    allServices.addAll(env.ANGULAR_SERVICES.split(','))

                    def servicesToPush = allServices.findAll { service ->
                        BUILD_REGISTRY.containsKey(service) && 
                        BUILD_REGISTRY[service] != null &&
                        BUILD_REGISTRY[service].dockerImage != null
                    }

                    if (servicesToPush.isEmpty()) {
                        echo "âš ï¸ No Docker images to push"
                        return
                    }

                    echo "ðŸ“¦ Pushing images for: ${servicesToPush.join(', ')}"

                    docker.withRegistry('https://registry.hub.docker.com', env.DOCKER_HUB_CREDENTIALS) {
                        for (service in servicesToPush) {
                            try {
                                def metadata = BUILD_REGISTRY[service]
                                echo "ðŸ“¤ Pushing ${metadata.dockerImage}:${metadata.dockerTag}"
                                docker.image("${metadata.dockerImage}:${metadata.dockerTag}").push()
                                docker.image("${metadata.dockerImage}:latest").push()
                                echo "âœ… ${service} pushed successfully"
                            } catch (Exception e) {
                                echo "âŒ Failed to push ${service}: ${e.message}"
                            }
                        }
                    }

                    echo "âœ… Docker push stage completed"
                }
            }
        }

        stage('Generate Build Report') {
            steps {
                script {
                    echo "ðŸ“Š Generating build report..."

                    def report = """
========================================
SmartEvent AI - Build Report #${BUILD_NUMBER}
========================================
"""

                    // PostgreSQL Info
                    report += "\nDATABASE:\n"
                    if (BUILD_REGISTRY.containsKey('postgres')) {
                        def pg = BUILD_REGISTRY['postgres']
                        report += """    âœ… PostgreSQL
      Container: ${pg.container}
      Host: ${pg.host}
      Port: ${pg.port}
      Database: ${pg.database}
"""
                    }

                    // Spring Services
                    report += "\nSPRING BOOT SERVICES:\n"
                    env.SPRING_SERVICES.split(',').each { service ->
                        if (BUILD_REGISTRY.containsKey(service) && BUILD_REGISTRY[service] != null) {
                            def meta = BUILD_REGISTRY[service]
                            report += """    - ${service}
      Version: ${meta.version ?: 'N/A'}
      Docker: ${meta.dockerImage ?: 'N/A'}:${meta.dockerTag ?: 'N/A'}
"""
                        } else {
                            report += "    - ${service}: NOT BUILT\n"
                        }
                    }

                    // Python Services
                    report += "\nPYTHON SERVICES:\n"
                    env.PYTHON_SERVICES.split(',').each { service ->
                        if (BUILD_REGISTRY.containsKey(service) && BUILD_REGISTRY[service] != null) {
                            def meta = BUILD_REGISTRY[service]
                            report += """    - ${service}
      Version: ${meta.version ?: 'N/A'}
      Docker: ${meta.dockerImage ?: 'N/A'}:${meta.dockerTag ?: 'N/A'}
"""
                        } else {
                            report += "    - ${service}: NOT BUILT\n"
                        }
                    }

                    // Node.js Services
                    report += "\nNODE.JS SERVICES:\n"
                    env.NODE_SERVICES.split(',').each { service ->
                        if (BUILD_REGISTRY.containsKey(service) && BUILD_REGISTRY[service] != null) {
                            def meta = BUILD_REGISTRY[service]
                            report += """    - ${service}
      Version: ${meta.version ?: 'N/A'}
      Docker: ${meta.dockerImage ?: 'N/A'}:${meta.dockerTag ?: 'N/A'}
"""
                        } else {
                            report += "    - ${service}: NOT BUILT\n"
                        }
                    }

                    // Angular Services
                    report += "\nANGULAR FRONTENDS:\n"
                    env.ANGULAR_SERVICES.split(',').each { service ->
                        if (BUILD_REGISTRY.containsKey(service) && BUILD_REGISTRY[service] != null) {
                            def meta = BUILD_REGISTRY[service]
                            report += """    - ${service}
      Version: ${meta.version ?: 'N/A'}
      Docker: ${meta.dockerImage ?: 'N/A'}:${meta.dockerTag ?: 'N/A'}
"""
                        } else {
                            report += "    - ${service}: NOT BUILT\n"
                        }
                    }

                    report += "\n=======================================\n"
                    report += "\nBUILD SUMMARY:\n"
                    report += "Total Services: ${env.SPRING_SERVICES.split(',').size() + env.PYTHON_SERVICES.split(',').size() + env.NODE_SERVICES.split(',').size() + env.ANGULAR_SERVICES.split(',').size()}\n"
                    report += "Successfully Built: ${BUILD_REGISTRY.size() - 1}\n"  // -1 pour exclure postgres
                    report += "Failed/Skipped: ${(env.SPRING_SERVICES.split(',').size() + env.PYTHON_SERVICES.split(',').size() + env.NODE_SERVICES.split(',').size() + env.ANGULAR_SERVICES.split(',').size()) - (BUILD_REGISTRY.size() - 1)}\n"
                    report += "=======================================\n"

                    echo report

                    writeFile file: "build-report-${BUILD_NUMBER}.txt", text: report
                    archiveArtifacts artifacts: "build-report-${BUILD_NUMBER}.txt", allowEmptyArchive: true
                }
            }
        }
    }

    post {
        success {
            script {
                echo "âœ… CI Pipeline completed successfully!"
                echo "ðŸš€ Triggering CD Pipeline..."

                build job: env.DOWNSTREAM_PIPELINE,
                      wait: false,
                      parameters: [
                          string(name: 'CI_BUILD_NUMBER', value: "${BUILD_NUMBER}"),
                          string(name: 'DOCKER_TAG', value: "build-${BUILD_NUMBER}")
                      ]
            }
        }
        failure {
            echo "âŒ CI Pipeline failed!"
        }
        always {
            script {
                echo "ðŸ§¹ Cleaning up..."
                
                // ArrÃªter et supprimer le container PostgreSQL
                sh """
                    docker stop ${POSTGRES_CONTAINER} 2>/dev/null || true
                    docker rm ${POSTGRES_CONTAINER} 2>/dev/null || true
                """
                
                cleanWs()
            }
        }
    }
}
