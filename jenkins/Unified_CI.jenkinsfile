pipeline {
    agent any

    tools {
        maven 'M2_HOME'
        jdk 'JAVA_HOME'
    }

    environment {
        // Global
        GITHUB_REPO_URL = 'https://github.com/YoussefGuetat/SmartEventAI.git'
        GIT_BRANCH = 'main'
        GITHUB_CREDENTIALS = 'github_credentials'
        DOCKER_HUB_CREDENTIALS = 'docker_hub_credentials'
        DOCKERHUB_NAMESPACE = 'SmartEventAI'

        // Downstream
        DOWNSTREAM_PIPELINE = 'SmartEvent_CD'

        // SonarQube
        SONAR_HOST_URL = 'http://localhost:9000'
        SONAR_LOGIN = credentials('sonar11')

        // Services
        SPRING_SERVICES = 'config-server,eureka-server,gateway-service,auth-service,event-service'
        NODE_SERVICES = 'workflow-service'
        PYTHON_SERVICES = 'ai-service'
        ANGULAR_SERVICES = 'frontAdmin'
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "=========================================="
                    echo "  SmartEvent AI - Unified CI Pipeline"
                    echo "  Build #${BUILD_NUMBER}"
                    echo "=========================================="

                    // Initialize global build registry
                    BUILD_REGISTRY = [:]

                    // Clone repository
                    git url: env.GITHUB_REPO_URL,
                        branch: env.GIT_BRANCH,
                        credentialsId: env.GITHUB_CREDENTIALS
                }
            }
        }
        
       stage('Build Docker Images') {
    steps {
        script {
            echo "üê≥ Building Docker images for all services..."

            def allServices = []
            allServices.addAll(env.SPRING_SERVICES.split(','))
            allServices.addAll(env.PYTHON_SERVICES.split(','))
            allServices.addAll(env.NODE_SERVICES.split(','))
            allServices.addAll(env.ANGULAR_SERVICES.split(','))

            // Filtrer uniquement les services qui ont √©t√© construits avec succ√®s
            def successfulServices = allServices.findAll { service ->
                BUILD_REGISTRY.containsKey(service) && BUILD_REGISTRY[service] != null
            }

            if (successfulServices.isEmpty()) {
                echo "‚ö†Ô∏è No services to build Docker images for"
                return
            }

            echo "üì¶ Building Docker images for: ${successfulServices.join(', ')}"

            for (service in successfulServices) {
                stage("Docker Build ${service}") {
                    dir(service) {
                        def metadata = BUILD_REGISTRY[service]
                        def imageName = "${DOCKERHUB_NAMESPACE}/${service}"
                        def imageTag = "build-${BUILD_NUMBER}"

                        echo "üê≥ Building Docker image: ${imageName}:${imageTag}"

                        if (fileExists('Dockerfile')) {
                            try {
                                if (metadata.type == 'spring' && metadata.jarFile) {
                                    if (fileExists(metadata.jarFile)) {
                                        docker.build("${imageName}:${imageTag}", "--build-arg JAR_FILE=${metadata.jarFile} .")
                                    } else {
                                        echo "‚ö†Ô∏è JAR file not found: ${metadata.jarFile}"
                                        error("JAR file not found")
                                    }
                                } else {
                                    docker.build("${imageName}:${imageTag}", ".")
                                }

                                docker.image("${imageName}:${imageTag}").tag('latest')

                                BUILD_REGISTRY[service].dockerImage = imageName
                                BUILD_REGISTRY[service].dockerTag = imageTag

                                echo "‚úÖ Docker image built: ${imageName}:${imageTag}"
                            } catch (Exception e) {
                                echo "‚ùå Failed to build Docker image for ${service}: ${e.message}"
                                // Ne pas faire √©chouer le pipeline, continuer avec les autres services
                            }
                        } else {
                            echo "‚ö†Ô∏è Dockerfile not found for ${service}"
                        }
                    }
                }
            }
        }
    }
}

      stage('Push Docker Images') {
    steps {
        script {
            echo "üì§ Pushing Docker images to Docker Hub..."

            def allServices = []
            allServices.addAll(env.SPRING_SERVICES.split(','))
            allServices.addAll(env.PYTHON_SERVICES.split(','))
            allServices.addAll(env.NODE_SERVICES.split(','))
            allServices.addAll(env.ANGULAR_SERVICES.split(','))

            // Filtrer uniquement les services qui ont une image Docker
            def servicesToPush = allServices.findAll { service ->
                BUILD_REGISTRY.containsKey(service) && 
                BUILD_REGISTRY[service] != null &&
                BUILD_REGISTRY[service].dockerImage != null
            }

            if (servicesToPush.isEmpty()) {
                echo "‚ö†Ô∏è No Docker images to push"
                return
            }

            echo "üì¶ Pushing images for: ${servicesToPush.join(', ')}"

            docker.withRegistry('https://registry.hub.docker.com', env.DOCKER_HUB_CREDENTIALS) {
                for (service in servicesToPush) {
                    try {
                        def metadata = BUILD_REGISTRY[service]
                        echo "üì§ Pushing ${metadata.dockerImage}:${metadata.dockerTag}"
                        docker.image("${metadata.dockerImage}:${metadata.dockerTag}").push()
                        docker.image("${metadata.dockerImage}:latest").push()
                        echo "‚úÖ ${service} pushed successfully"
                    } catch (Exception e) {
                        echo "‚ùå Failed to push ${service}: ${e.message}"
                    }
                }
            }

            echo "‚úÖ Docker push stage completed"
        }
    }
}

        stage('Generate Build Report') {
            steps {
                script {
                    echo "üìä Generating build report..."

                    def report = """
                    ========================================
                    SmartEvent AI - Build Report #${BUILD_NUMBER}
                    ========================================
                    
                    SPRING BOOT SERVICES:
                    """
                    env.SPRING_SERVICES.split(',').each { service ->
                        def meta = BUILD_REGISTRY[service]
                        report += """
                        - ${service}
                          Version: ${meta.version}
                          Docker: ${meta.dockerImage}:${meta.dockerTag}
                        """
                    }

                    report += "\nPYTHON SERVICES:\n"
                    env.PYTHON_SERVICES.split(',').each { service ->
                        def meta = BUILD_REGISTRY[service]
                        report += """
                        - ${service}
                          Docker: ${meta.dockerImage}:${meta.dockerTag}
                        """
                    }

                    report += "\nNODE.JS SERVICES:\n"
                    env.NODE_SERVICES.split(',').each { service ->
                        def meta = BUILD_REGISTRY[service]
                        report += """
                        - ${service}
                          Docker: ${meta.dockerImage}:${meta.dockerTag}
                        """
                    }

                    report += "\nANGULAR FRONTENDS:\n"
                    env.ANGULAR_SERVICES.split(',').each { service ->
                        def meta = BUILD_REGISTRY[service]
                        report += """
                        - ${service}
                          Docker: ${meta.dockerImage}:${meta.dockerTag}
                        """
                    }

                    report += "\n=======================================\n"

                    echo report

                    writeFile file: "build-report-${BUILD_NUMBER}.txt", text: report
                    archiveArtifacts artifacts: "build-report-${BUILD_NUMBER}.txt"
                }
            }
        }
    }

    post {
        success {
            script {
                echo "‚úÖ CI Pipeline completed successfully!"
                echo "üöÄ Triggering CD Pipeline..."

                build job: env.DOWNSTREAM_PIPELINE,
                      wait: false,
                      parameters: [
                          string(name: 'CI_BUILD_NUMBER', value: "${BUILD_NUMBER}"),
                          string(name: 'DOCKER_TAG', value: "build-${BUILD_NUMBER}")
                      ]
            }
        }
        failure {
            echo "‚ùå CI Pipeline failed!"
        }
        always {
            echo "üßπ Cleaning up..."
            cleanWs()
        }
    }
}
