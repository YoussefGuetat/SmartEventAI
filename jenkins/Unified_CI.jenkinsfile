pipeline {
    agent any

    tools {
        maven 'M2_HOME'
        jdk 'JAVA_HOME'
    }

    environment {
        // Global
        GITHUB_REPO_URL = 'https://github.com/YoussefGuetat/SmartEventAI.git'
        GIT_BRANCH = 'main'
        GITHUB_CREDENTIALS = 'github_credentials'
        DOCKER_HUB_CREDENTIALS = 'docker_hub_credentials'
        DOCKERHUB_NAMESPACE = 'SmartEventAI'

        // Downstream
        DOWNSTREAM_PIPELINE = 'SmartEvent_CD'

        // SonarQube
        SONAR_HOST_URL = 'http://localhost:9000'
        SONAR_LOGIN = credentials('sonar11')

        // Services
        SPRING_SERVICES = 'config-server,eureka-server,gateway-service,auth-service,event-service'
        NODE_SERVICES = 'workflow-service'
        PYTHON_SERVICES = 'ai-service'
        ANGULAR_SERVICES = 'frontAdmin'
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "=========================================="
                    echo "  SmartEvent AI - Unified CI Pipeline"
                    echo "  Build #${BUILD_NUMBER}"
                    echo "=========================================="

                    // Initialize global build registry
                    BUILD_REGISTRY = [:]

                    // Clone repository
                    git url: env.GITHUB_REPO_URL,
                        branch: env.GIT_BRANCH,
                        credentialsId: env.GITHUB_CREDENTIALS
                }
            }
        }
        
       stage('Build Docker Images') {
    steps {
        script {
            echo "üê≥ Building Docker images for all services..."

            def allServices = []
            allServices.addAll(env.SPRING_SERVICES.split(','))
            allServices.addAll(env.PYTHON_SERVICES.split(','))
            allServices.addAll(env.NODE_SERVICES.split(','))
            allServices.addAll(env.ANGULAR_SERVICES.split(','))

            for (service in allServices) {
                stage("Docker Build ${service}") {
                    dir(service) {
                        // V√©rifier que le service existe dans BUILD_REGISTRY
                        if (!BUILD_REGISTRY.containsKey(service)) {
                            echo "‚ö†Ô∏è ${service} not found in BUILD_REGISTRY, skipping Docker build"
                            continue
                        }

                        def metadata = BUILD_REGISTRY[service]
                        
                        // V√©rifier que metadata n'est pas null
                        if (metadata == null) {
                            echo "‚ö†Ô∏è ${service} metadata is null, skipping Docker build"
                            continue
                        }

                        def imageName = "${DOCKERHUB_NAMESPACE}/${service}"
                        def imageTag = "build-${BUILD_NUMBER}"

                        echo "üê≥ Building Docker image: ${imageName}:${imageTag}"

                        // V√©rifier que le Dockerfile existe
                        if (!fileExists('Dockerfile')) {
                            echo "‚ö†Ô∏è Dockerfile not found for ${service}, skipping Docker build"
                            continue
                        }

                        try {
                            if (metadata.type == 'spring') {
                                // V√©rifier que le JAR existe
                                if (!fileExists(metadata.jarFile)) {
                                    echo "‚ö†Ô∏è JAR file ${metadata.jarFile} not found for ${service}"
                                    continue
                                }
                                docker.build("${imageName}:${imageTag}", "--build-arg JAR_FILE=${metadata.jarFile} .")
                            } else {
                                docker.build("${imageName}:${imageTag}", ".")
                            }

                            docker.image("${imageName}:${imageTag}").tag('latest')

                            BUILD_REGISTRY[service].dockerImage = imageName
                            BUILD_REGISTRY[service].dockerTag = imageTag

                            echo "‚úÖ Docker image built: ${imageName}:${imageTag}"
                        } catch (Exception e) {
                            echo "‚ùå Failed to build Docker image for ${service}: ${e.message}"
                            // Continue avec les autres services
                        }
                    }
                }
            }
        }
    }
}

       stage('Push Docker Images') {
    steps {
        script {
            echo "üì§ Pushing Docker images to Docker Hub..."

            docker.withRegistry('https://registry.hub.docker.com', env.DOCKER_HUB_CREDENTIALS) {
                def allServices = []
                allServices.addAll(env.SPRING_SERVICES.split(','))
                allServices.addAll(env.PYTHON_SERVICES.split(','))
                allServices.addAll(env.NODE_SERVICES.split(','))
                allServices.addAll(env.ANGULAR_SERVICES.split(','))

                // Filtrer uniquement les services qui ont une image Docker
                def servicesToPush = allServices.findAll { service ->
                    BUILD_REGISTRY.containsKey(service) && 
                    BUILD_REGISTRY[service] != null &&
                    BUILD_REGISTRY[service].dockerImage != null
                }

                echo "üì¶ Services to push: ${servicesToPush.join(', ')}"

                for (service in servicesToPush) {
                    try {
                        def metadata = BUILD_REGISTRY[service]
                        echo "üì§ Pushing ${metadata.dockerImage}:${metadata.dockerTag}"
                        docker.image("${metadata.dockerImage}:${metadata.dockerTag}").push()
                        docker.image("${metadata.dockerImage}:latest").push()
                        echo "‚úÖ ${service} pushed successfully"
                    } catch (Exception e) {
                        echo "‚ùå Failed to push ${service}: ${e.message}"
                    }
                }
            }

            echo "‚úÖ Docker push completed"
        }
    }
}

        stage('Generate Build Report') {
            steps {
                script {
                    echo "üìä Generating build report..."

                    def report = """
                    ========================================
                    SmartEvent AI - Build Report #${BUILD_NUMBER}
                    ========================================
                    
                    SPRING BOOT SERVICES:
                    """
                    env.SPRING_SERVICES.split(',').each { service ->
                        def meta = BUILD_REGISTRY[service]
                        report += """
                        - ${service}
                          Version: ${meta.version}
                          Docker: ${meta.dockerImage}:${meta.dockerTag}
                        """
                    }

                    report += "\nPYTHON SERVICES:\n"
                    env.PYTHON_SERVICES.split(',').each { service ->
                        def meta = BUILD_REGISTRY[service]
                        report += """
                        - ${service}
                          Docker: ${meta.dockerImage}:${meta.dockerTag}
                        """
                    }

                    report += "\nNODE.JS SERVICES:\n"
                    env.NODE_SERVICES.split(',').each { service ->
                        def meta = BUILD_REGISTRY[service]
                        report += """
                        - ${service}
                          Docker: ${meta.dockerImage}:${meta.dockerTag}
                        """
                    }

                    report += "\nANGULAR FRONTENDS:\n"
                    env.ANGULAR_SERVICES.split(',').each { service ->
                        def meta = BUILD_REGISTRY[service]
                        report += """
                        - ${service}
                          Docker: ${meta.dockerImage}:${meta.dockerTag}
                        """
                    }

                    report += "\n=======================================\n"

                    echo report

                    writeFile file: "build-report-${BUILD_NUMBER}.txt", text: report
                    archiveArtifacts artifacts: "build-report-${BUILD_NUMBER}.txt"
                }
            }
        }
    }

    post {
        success {
            script {
                echo "‚úÖ CI Pipeline completed successfully!"
                echo "üöÄ Triggering CD Pipeline..."

                build job: env.DOWNSTREAM_PIPELINE,
                      wait: false,
                      parameters: [
                          string(name: 'CI_BUILD_NUMBER', value: "${BUILD_NUMBER}"),
                          string(name: 'DOCKER_TAG', value: "build-${BUILD_NUMBER}")
                      ]
            }
        }
        failure {
            echo "‚ùå CI Pipeline failed!"
        }
        always {
            echo "üßπ Cleaning up..."
            cleanWs()
        }
    }
}
